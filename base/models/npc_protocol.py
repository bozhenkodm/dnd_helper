# flake8: noqa
# mypy: ignore-errors
from typing import TYPE_CHECKING, Iterable, Optional, Protocol, Sequence, Union

from django.contrib.auth.models import User
from django.db.models.manager import Manager
from django.db.models.query import QuerySet
from django.db.models.query_utils import Q

if TYPE_CHECKING:

    from base.constants.constants import (
        AbilityEnum,
        AccessoryTypeEnum,
        DefenceTypeEnum,
        NPCOtherProperties,
        PowerVariables,
        SkillEnum,
    )
    from base.models.abilities import Ability
    from base.models.feats import Feat
    from base.models.items import (
        Armor,
        ArmsSlotItem,
        FeetSlotItem,
        HandsSlotItem,
        HeadSlotItem,
        ItemAbstract,
        MagicItemType,
        NeckSlotItem,
        RingsSlotItem,
        WaistSlotItem,
        Weapon,
        WeaponType,
    )
    from base.models.klass import Class, Subclass
    from base.models.models import FunctionalTemplate, ParagonPath, Race
    from base.models.powers import Power
    from base.models.skills import Skill
    from base.objects.abilities import Abilities
    from base.objects.dice import DiceRoll
    from base.objects.skills import Skills


class NPCProtocol(Protocol):
    OPERATORS: dict

    id: int
    neck_slot: 'NeckSlotItem'
    head_slot: 'HeadSlotItem'
    feet_slot: 'FeetSlotItem'
    waist_slot: 'WaistSlotItem'
    gloves_slot: 'HandsSlotItem'
    left_ring_slot: 'RingsSlotItem'
    right_ring_slot: 'RingsSlotItem'
    arms_slot: 'ArmsSlotItem'
    base_strength: int
    base_constitution: int
    base_dexterity: int
    base_intelligence: int
    base_wisdom: int
    base_charisma: int
    var_bonus_ability: 'Ability'
    experience: int
    klass: 'Class'
    subclass_id: int
    owner: 'User'
    name: str
    description: str
    race: 'Race'
    functional_template: 'FunctionalTemplate'
    paragon_path: 'ParagonPath'
    sex: str
    level: int
    is_bonus_applied: bool
    armor: 'Armor'
    primary_hand: 'Weapon'
    secondary_hand: 'Weapon'
    no_hand: 'Weapon'
    feats: Manager['Feat']
    trained_weapons: Manager['WeaponType']
    level_ability_bonuses: Manager['Ability']
    trained_skills: Manager['Skill']
    powers: Manager['Power']

    def attack_bonus(self, weapon=..., is_implement: bool = ...) -> int: ...
    def cache_all(self): ...
    def cache_bonuses(self): ...
    def cache_powers(self): ...
    def calculate_bonus(
        self,
        bonus_type: Union[
            'AbilityEnum', 'SkillEnum', 'DefenceTypeEnum', 'NPCOtherProperties'
        ],
    ) -> int: ...
    def calculate_bonuses(
        self,
        *bonus_types: Union[
            'AbilityEnum', 'SkillEnum', 'DefenceTypeEnum', 'NPCOtherProperties'
        ],
        check_cache: bool = False,
    ) -> dict[
        Union['AbilityEnum', 'SkillEnum', 'DefenceTypeEnum', 'NPCOtherProperties'], int
    ]: ...
    def calculate_reverse_polish_notation(
        self,
        expression: str,
        accessory_type: Optional['AccessoryTypeEnum'],
        weapon=...,
        secondary_weapon=...,
        item=...,
    ): ...
    def calculate_token(
        self,
        token: str,
        accessory_type: Optional['AccessoryTypeEnum'],
        weapon=...,
        secondary_weapon=...,
        item=...,
    ) -> Union[int, 'DiceRoll']: ...
    def enhancement_with_magic_threshold(self, enhancement: int) -> int: ...
    def evaluate_power_expression(
        self,
        string: str,
        accessory_type: Optional['AccessoryTypeEnum'] = ...,
        weapon=...,
        secondary_weapon=...,
        item=...,
    ): ...
    def feats_calculated(self): ...
    def get_ability_text(self, ability: 'Ability') -> str: ...
    def get_absolute_url(self) -> str: ...
    def get_power_display(
        self,
        power: 'Power',
        weapons: Sequence['Weapon'] = ...,
        item: Optional['ItemAbstract'] = ...,
    ) -> dict[str, str]: ...
    def get_power_feats_bonuses_query(self) -> 'Q': ...
    def is_implement_proficient(self, weapon: 'Weapon') -> bool: ...
    def is_weapon_proficient(self, weapon: 'Weapon') -> bool: ...
    def magic_item_powers(self) -> 'QuerySet': ...
    def parse_string(
        self,
        accessory_type: Optional['AccessoryTypeEnum'],
        string: str,
        weapons: Sequence['Weapon'] = ...,
        item: Optional['ItemAbstract'] = ...,
    ): ...
    def powers_calculate(self) -> Sequence[dict]: ...
    def powers_calculated(self) -> Sequence[dict]: ...
    def proper_weapons_for_power(
        self, power: 'Power'
    ) -> Sequence[tuple['Weapon', Ellipsis]]: ...
    def valid_properties(self, power: 'Power'): ...
    @property
    def abilities_texts(self) -> list[str]: ...
    @property
    def acrobatics(self) -> int: ...
    @property
    def arcana(self) -> int: ...
    @property
    def armor_class(self) -> int: ...
    @property
    def armor_class_bonus(self) -> int: ...
    @property
    def athletics(self) -> int: ...
    @property
    def available_armor_types(self) -> 'QuerySet': ...
    @property
    def available_shield_types(self) -> 'QuerySet': ...
    @property
    def available_weapon_categories(self) -> 'QuerySet': ...
    @property
    def bloodied(self) -> int: ...
    @property
    def bluff(self) -> int: ...
    @property
    def cha_mod(self) -> int: ...
    @property
    def charisma(self) -> int: ...
    @property
    def con_mod(self) -> int: ...
    @property
    def constitution(self) -> int: ...
    @property
    def damage_bonus(self) -> int: ...
    @property
    def dex_mod(self) -> int: ...
    @property
    def dexterity(self) -> int: ...
    @property
    def diplomacy(self) -> int: ...
    @property
    def dungeoneering(self) -> int: ...
    @property
    def endurance(self) -> int: ...
    @property
    def feats_count(self) -> int: ...
    @property
    def fortitude(self) -> int: ...
    @property
    def full_class_name(self) -> str: ...
    @property
    def half_level(self) -> int: ...
    @property
    def heal(self) -> int: ...
    @property
    def history(self) -> int: ...
    @property
    def initiative(self) -> int: ...
    @property
    def insight(self) -> int: ...
    @property
    def int_mod(self) -> int: ...
    @property
    def intelligence(self) -> int: ...
    @property
    def intimidate(self) -> int: ...
    @property
    def inventory_text(self) -> Iterable[str]: ...
    @property
    def items(self) -> tuple['ItemAbstract', Ellipsis]: ...
    @property
    def magic_item_types(self) -> Sequence['MagicItemType']: ...
    @property
    def magic_items(self) -> Sequence['ItemAbstract']: ...
    @property
    def max_feats_number(self) -> int: ...
    @property
    def max_hit_points(self) -> int: ...
    @property
    def nature(self) -> int: ...
    @property
    def perception(self) -> int: ...
    @property
    def power_source(self) -> int: ...
    @property
    def reflex(self) -> int: ...
    @property
    def religion(self) -> int: ...
    @property
    def role(self) -> int: ...
    @property
    def shield(self) -> Optional['ShieldType']: ...
    @property
    def skill_mod_bonus(self) -> 'Skills': ...
    @property
    def skills(self) -> 'Skills': ...
    @property
    def skills_text(self) -> list[str]: ...
    @property
    def speed(self) -> int: ...
    @property
    def stealth(self) -> int: ...
    @property
    def str_mod(self) -> int: ...
    @property
    def streetwise(self) -> int: ...
    @property
    def strength(self) -> int: ...
    @property
    def subclass(self) -> 'Subclass': ...
    @property
    def surge(self) -> int: ...
    @property
    def surges(self) -> int: ...
    @property
    def thievery(self) -> int: ...
    @property
    def url(self) -> str: ...
    @property
    def will(self) -> int: ...
    @property
    def wis_mod(self) -> int: ...
    @property
    def wisdom(self) -> int: ...

    @property
    def _level_bonus(self) -> int: ...
    @property
    def _armor_class_ability_bonus(self) -> int: ...

    @property
    def _defence_level_bonus(self) -> int: ...

    @property
    def _shield_bonus(self) -> int: ...

    @property
    def _necklace_defence_bonus(self) -> int: ...

    @property
    def _bonus_cache_key(self) -> str: ...
    @property
    def _initial_abilities_bonuses(self) -> 'Abilities': ...

    @property
    def _tier_attrs_bonus(self) -> 'Abilities': ...

    @property
    def _level_abilities_bonuses(self) -> 'Abilities': ...

    @property
    def _base_abilities(self) -> 'Abilities': ...

    @property
    def _tier(self) -> int: ...
    @property
    def _abilities(self) -> 'Abilities': ...
    @property
    def _is_no_hand_implement_ki_focus(self) -> bool: ...

    def _can_get_bonus_from_implement_to_weapon(
        self, accessory_type: Optional['AccessoryTypeEnum']
    ) -> bool: ...
    @property
    def _magic_threshold(self) -> int: ...
    def _calculate_weapon_damage(
        self, weapon: 'Weapon', accessory_type: Optional['AccessoryTypeEnum']
    ) -> 'DiceRoll': ...

    def _calculate_attack(
        self, weapon: 'Weapon', accessory_type: Optional['AccessoryTypeEnum']
    ) -> int: ...
    def _calculate_damage_bonus(
        self, weapon: 'Weapon', accessory_type: Optional['AccessoryTypeEnum']
    ) -> int: ...

    @property
    def _power_attrs(self) -> dict[Union['PowerVariables', str], int]: ...
    @classmethod
    def expression_to_reverse_polish_notation(cls, string: str) -> str: ...
    @property
    def _powers_cache_key(self) -> str: ...
